/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.cohere.api.requests;

import com.cohere.api.core.ObjectMappers;
import com.cohere.api.types.ChatConnector;
import com.cohere.api.types.ChatMessage;
import com.cohere.api.types.ChatRequestCitationQuality;
import com.cohere.api.types.ChatRequestPromptTruncation;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonDeserialize(builder = ChatRequest.Builder.class)
public final class ChatRequest {
    private final String message;

    private final Optional<String> model;

    private final Optional<String> preambleOverride;

    private final Optional<List<ChatMessage>> chatHistory;

    private final Optional<String> conversationId;

    private final Optional<ChatRequestPromptTruncation> promptTruncation;

    private final Optional<List<ChatConnector>> connectors;

    private final Optional<Boolean> searchQueriesOnly;

    private final Optional<List<Map<String, String>>> documents;

    private final Optional<ChatRequestCitationQuality> citationQuality;

    private final Optional<Double> temperature;

    private final Optional<Integer> maxTokens;

    private final Optional<Integer> k;

    private final Optional<Double> p;

    private final Optional<Double> frequencyPenalty;

    private final Optional<Double> presencePenalty;

    private final Map<String, Object> additionalProperties;

    private ChatRequest(
            String message,
            Optional<String> model,
            Optional<String> preambleOverride,
            Optional<List<ChatMessage>> chatHistory,
            Optional<String> conversationId,
            Optional<ChatRequestPromptTruncation> promptTruncation,
            Optional<List<ChatConnector>> connectors,
            Optional<Boolean> searchQueriesOnly,
            Optional<List<Map<String, String>>> documents,
            Optional<ChatRequestCitationQuality> citationQuality,
            Optional<Double> temperature,
            Optional<Integer> maxTokens,
            Optional<Integer> k,
            Optional<Double> p,
            Optional<Double> frequencyPenalty,
            Optional<Double> presencePenalty,
            Map<String, Object> additionalProperties) {
        this.message = message;
        this.model = model;
        this.preambleOverride = preambleOverride;
        this.chatHistory = chatHistory;
        this.conversationId = conversationId;
        this.promptTruncation = promptTruncation;
        this.connectors = connectors;
        this.searchQueriesOnly = searchQueriesOnly;
        this.documents = documents;
        this.citationQuality = citationQuality;
        this.temperature = temperature;
        this.maxTokens = maxTokens;
        this.k = k;
        this.p = p;
        this.frequencyPenalty = frequencyPenalty;
        this.presencePenalty = presencePenalty;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Accepts a string.
     * The chat message from the user to the model.
     */
    @JsonProperty("message")
    public String getMessage() {
        return message;
    }

    /**
     * @return Defaults to <code>command</code>.
     * <p>The identifier of the model, which can be one of the existing Cohere models or the full ID for a <a href="https://docs.cohere.com/docs/chat-fine-tuning">fine-tuned custom model</a>.</p>
     * <p>Compatible Cohere models are <code>command</code> and <code>command-light</code> as well as the experimental <code>command-nightly</code> and <code>command-light-nightly</code> variants. Read more about <a href="https://docs.cohere.com/docs/models">Cohere models</a>.</p>
     */
    @JsonProperty("model")
    public Optional<String> getModel() {
        return model;
    }

    @JsonProperty("stream")
    public Boolean getStream() {
        return false;
    }

    /**
     * @return When specified, the default Cohere preamble will be replaced with the provided one.
     */
    @JsonProperty("preamble_override")
    public Optional<String> getPreambleOverride() {
        return preambleOverride;
    }

    /**
     * @return A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's <code>message</code>.
     */
    @JsonProperty("chat_history")
    public Optional<List<ChatMessage>> getChatHistory() {
        return chatHistory;
    }

    /**
     * @return An alternative to <code>chat_history</code>. Previous conversations can be resumed by providing the conversation's identifier. The contents of <code>message</code> and the model's response will be stored as part of this conversation.
     * <p>If a conversation with this id does not already exist, a new conversation will be created.</p>
     */
    @JsonProperty("conversation_id")
    public Optional<String> getConversationId() {
        return conversationId;
    }

    /**
     * @return Defaults to <code>AUTO</code> when <code>connectors</code> are specified and <code>OFF</code> in all other cases.
     * <p>Dictates how the prompt will be constructed.</p>
     * <p>With <code>prompt_truncation</code> set to &quot;AUTO&quot;, some elements from <code>chat_history</code> and <code>documents</code> will be dropped in an attempt to construct a prompt that fits within the model's context length limit.</p>
     * <p>With <code>prompt_truncation</code> set to &quot;OFF&quot;, no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a <code>TooManyTokens</code> error will be returned.</p>
     */
    @JsonProperty("prompt_truncation")
    public Optional<ChatRequestPromptTruncation> getPromptTruncation() {
        return promptTruncation;
    }

    /**
     * @return Accepts <code>{&quot;id&quot;: &quot;web-search&quot;}</code>, and/or the <code>&quot;id&quot;</code> for a custom <a href="https://docs.cohere.com/docs/connectors">connector</a>, if you've <a href="https://docs.cohere.com/docs/creating-and-deploying-a-connector">created</a> one.
     * <p>When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).</p>
     */
    @JsonProperty("connectors")
    public Optional<List<ChatConnector>> getConnectors() {
        return connectors;
    }

    /**
     * @return Defaults to <code>false</code>.
     * <p>When <code>true</code>, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's <code>message</code> will be generated.</p>
     */
    @JsonProperty("search_queries_only")
    public Optional<Boolean> getSearchQueriesOnly() {
        return searchQueriesOnly;
    }

    /**
     * @return A list of relevant documents that the model can use to enrich its reply. See <a href="https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode">'Document Mode'</a> in the guide for more information.
     */
    @JsonProperty("documents")
    public Optional<List<Map<String, String>>> getDocuments() {
        return documents;
    }

    /**
     * @return Defaults to <code>&quot;accurate&quot;</code>.
     * <p>Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want <code>&quot;accurate&quot;</code> results or <code>&quot;fast&quot;</code> results.</p>
     */
    @JsonProperty("citation_quality")
    public Optional<ChatRequestCitationQuality> getCitationQuality() {
        return citationQuality;
    }

    /**
     * @return Defaults to <code>0.3</code>.
     * <p>A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.</p>
     * <p>Randomness can be further maximized by increasing the  value of the <code>p</code> parameter.</p>
     */
    @JsonProperty("temperature")
    public Optional<Double> getTemperature() {
        return temperature;
    }

    /**
     * @return The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
     */
    @JsonProperty("max_tokens")
    public Optional<Integer> getMaxTokens() {
        return maxTokens;
    }

    /**
     * @return Ensures only the top <code>k</code> most likely tokens are considered for generation at each step.
     * Defaults to <code>0</code>, min value of <code>0</code>, max value of <code>500</code>.
     */
    @JsonProperty("k")
    public Optional<Integer> getK() {
        return k;
    }

    /**
     * @return Ensures that only the most likely tokens, with total probability mass of <code>p</code>, are considered for generation at each step. If both <code>k</code> and <code>p</code> are enabled, <code>p</code> acts after <code>k</code>.
     * Defaults to <code>0.75</code>. min value of <code>0.01</code>, max value of <code>0.99</code>.
     */
    @JsonProperty("p")
    public Optional<Double> getP() {
        return p;
    }

    /**
     * @return Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
     */
    @JsonProperty("frequency_penalty")
    public Optional<Double> getFrequencyPenalty() {
        return frequencyPenalty;
    }

    /**
     * @return Defaults to <code>0.0</code>, min value of <code>0.0</code>, max value of <code>1.0</code>. Can be used to reduce repetitiveness of generated tokens. Similar to <code>frequency_penalty</code>, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
     */
    @JsonProperty("presence_penalty")
    public Optional<Double> getPresencePenalty() {
        return presencePenalty;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ChatRequest && equalTo((ChatRequest) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ChatRequest other) {
        return message.equals(other.message)
                && model.equals(other.model)
                && preambleOverride.equals(other.preambleOverride)
                && chatHistory.equals(other.chatHistory)
                && conversationId.equals(other.conversationId)
                && promptTruncation.equals(other.promptTruncation)
                && connectors.equals(other.connectors)
                && searchQueriesOnly.equals(other.searchQueriesOnly)
                && documents.equals(other.documents)
                && citationQuality.equals(other.citationQuality)
                && temperature.equals(other.temperature)
                && maxTokens.equals(other.maxTokens)
                && k.equals(other.k)
                && p.equals(other.p)
                && frequencyPenalty.equals(other.frequencyPenalty)
                && presencePenalty.equals(other.presencePenalty);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.message,
                this.model,
                this.preambleOverride,
                this.chatHistory,
                this.conversationId,
                this.promptTruncation,
                this.connectors,
                this.searchQueriesOnly,
                this.documents,
                this.citationQuality,
                this.temperature,
                this.maxTokens,
                this.k,
                this.p,
                this.frequencyPenalty,
                this.presencePenalty);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static MessageStage builder() {
        return new Builder();
    }

    public interface MessageStage {
        _FinalStage message(String message);

        Builder from(ChatRequest other);
    }

    public interface _FinalStage {
        ChatRequest build();

        _FinalStage model(Optional<String> model);

        _FinalStage model(String model);

        _FinalStage preambleOverride(Optional<String> preambleOverride);

        _FinalStage preambleOverride(String preambleOverride);

        _FinalStage chatHistory(Optional<List<ChatMessage>> chatHistory);

        _FinalStage chatHistory(List<ChatMessage> chatHistory);

        _FinalStage conversationId(Optional<String> conversationId);

        _FinalStage conversationId(String conversationId);

        _FinalStage promptTruncation(Optional<ChatRequestPromptTruncation> promptTruncation);

        _FinalStage promptTruncation(ChatRequestPromptTruncation promptTruncation);

        _FinalStage connectors(Optional<List<ChatConnector>> connectors);

        _FinalStage connectors(List<ChatConnector> connectors);

        _FinalStage searchQueriesOnly(Optional<Boolean> searchQueriesOnly);

        _FinalStage searchQueriesOnly(Boolean searchQueriesOnly);

        _FinalStage documents(Optional<List<Map<String, String>>> documents);

        _FinalStage documents(List<Map<String, String>> documents);

        _FinalStage citationQuality(Optional<ChatRequestCitationQuality> citationQuality);

        _FinalStage citationQuality(ChatRequestCitationQuality citationQuality);

        _FinalStage temperature(Optional<Double> temperature);

        _FinalStage temperature(Double temperature);

        _FinalStage maxTokens(Optional<Integer> maxTokens);

        _FinalStage maxTokens(Integer maxTokens);

        _FinalStage k(Optional<Integer> k);

        _FinalStage k(Integer k);

        _FinalStage p(Optional<Double> p);

        _FinalStage p(Double p);

        _FinalStage frequencyPenalty(Optional<Double> frequencyPenalty);

        _FinalStage frequencyPenalty(Double frequencyPenalty);

        _FinalStage presencePenalty(Optional<Double> presencePenalty);

        _FinalStage presencePenalty(Double presencePenalty);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements MessageStage, _FinalStage {
        private String message;

        private Optional<Double> presencePenalty = Optional.empty();

        private Optional<Double> frequencyPenalty = Optional.empty();

        private Optional<Double> p = Optional.empty();

        private Optional<Integer> k = Optional.empty();

        private Optional<Integer> maxTokens = Optional.empty();

        private Optional<Double> temperature = Optional.empty();

        private Optional<ChatRequestCitationQuality> citationQuality = Optional.empty();

        private Optional<List<Map<String, String>>> documents = Optional.empty();

        private Optional<Boolean> searchQueriesOnly = Optional.empty();

        private Optional<List<ChatConnector>> connectors = Optional.empty();

        private Optional<ChatRequestPromptTruncation> promptTruncation = Optional.empty();

        private Optional<String> conversationId = Optional.empty();

        private Optional<List<ChatMessage>> chatHistory = Optional.empty();

        private Optional<String> preambleOverride = Optional.empty();

        private Optional<String> model = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(ChatRequest other) {
            message(other.getMessage());
            model(other.getModel());
            preambleOverride(other.getPreambleOverride());
            chatHistory(other.getChatHistory());
            conversationId(other.getConversationId());
            promptTruncation(other.getPromptTruncation());
            connectors(other.getConnectors());
            searchQueriesOnly(other.getSearchQueriesOnly());
            documents(other.getDocuments());
            citationQuality(other.getCitationQuality());
            temperature(other.getTemperature());
            maxTokens(other.getMaxTokens());
            k(other.getK());
            p(other.getP());
            frequencyPenalty(other.getFrequencyPenalty());
            presencePenalty(other.getPresencePenalty());
            return this;
        }

        /**
         * <p>Accepts a string.
         * The chat message from the user to the model.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("message")
        public _FinalStage message(String message) {
            this.message = message;
            return this;
        }

        /**
         * <p>Defaults to <code>0.0</code>, min value of <code>0.0</code>, max value of <code>1.0</code>. Can be used to reduce repetitiveness of generated tokens. Similar to <code>frequency_penalty</code>, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage presencePenalty(Double presencePenalty) {
            this.presencePenalty = Optional.of(presencePenalty);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "presence_penalty", nulls = Nulls.SKIP)
        public _FinalStage presencePenalty(Optional<Double> presencePenalty) {
            this.presencePenalty = presencePenalty;
            return this;
        }

        /**
         * <p>Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage frequencyPenalty(Double frequencyPenalty) {
            this.frequencyPenalty = Optional.of(frequencyPenalty);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "frequency_penalty", nulls = Nulls.SKIP)
        public _FinalStage frequencyPenalty(Optional<Double> frequencyPenalty) {
            this.frequencyPenalty = frequencyPenalty;
            return this;
        }

        /**
         * <p>Ensures that only the most likely tokens, with total probability mass of <code>p</code>, are considered for generation at each step. If both <code>k</code> and <code>p</code> are enabled, <code>p</code> acts after <code>k</code>.
         * Defaults to <code>0.75</code>. min value of <code>0.01</code>, max value of <code>0.99</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage p(Double p) {
            this.p = Optional.of(p);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "p", nulls = Nulls.SKIP)
        public _FinalStage p(Optional<Double> p) {
            this.p = p;
            return this;
        }

        /**
         * <p>Ensures only the top <code>k</code> most likely tokens are considered for generation at each step.
         * Defaults to <code>0</code>, min value of <code>0</code>, max value of <code>500</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage k(Integer k) {
            this.k = Optional.of(k);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "k", nulls = Nulls.SKIP)
        public _FinalStage k(Optional<Integer> k) {
            this.k = k;
            return this;
        }

        /**
         * <p>The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage maxTokens(Integer maxTokens) {
            this.maxTokens = Optional.of(maxTokens);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "max_tokens", nulls = Nulls.SKIP)
        public _FinalStage maxTokens(Optional<Integer> maxTokens) {
            this.maxTokens = maxTokens;
            return this;
        }

        /**
         * <p>Defaults to <code>0.3</code>.</p>
         * <p>A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.</p>
         * <p>Randomness can be further maximized by increasing the  value of the <code>p</code> parameter.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage temperature(Double temperature) {
            this.temperature = Optional.of(temperature);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "temperature", nulls = Nulls.SKIP)
        public _FinalStage temperature(Optional<Double> temperature) {
            this.temperature = temperature;
            return this;
        }

        /**
         * <p>Defaults to <code>&quot;accurate&quot;</code>.</p>
         * <p>Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want <code>&quot;accurate&quot;</code> results or <code>&quot;fast&quot;</code> results.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage citationQuality(ChatRequestCitationQuality citationQuality) {
            this.citationQuality = Optional.of(citationQuality);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "citation_quality", nulls = Nulls.SKIP)
        public _FinalStage citationQuality(Optional<ChatRequestCitationQuality> citationQuality) {
            this.citationQuality = citationQuality;
            return this;
        }

        /**
         * <p>A list of relevant documents that the model can use to enrich its reply. See <a href="https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode">'Document Mode'</a> in the guide for more information.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage documents(List<Map<String, String>> documents) {
            this.documents = Optional.of(documents);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "documents", nulls = Nulls.SKIP)
        public _FinalStage documents(Optional<List<Map<String, String>>> documents) {
            this.documents = documents;
            return this;
        }

        /**
         * <p>Defaults to <code>false</code>.</p>
         * <p>When <code>true</code>, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's <code>message</code> will be generated.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage searchQueriesOnly(Boolean searchQueriesOnly) {
            this.searchQueriesOnly = Optional.of(searchQueriesOnly);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "search_queries_only", nulls = Nulls.SKIP)
        public _FinalStage searchQueriesOnly(Optional<Boolean> searchQueriesOnly) {
            this.searchQueriesOnly = searchQueriesOnly;
            return this;
        }

        /**
         * <p>Accepts <code>{&quot;id&quot;: &quot;web-search&quot;}</code>, and/or the <code>&quot;id&quot;</code> for a custom <a href="https://docs.cohere.com/docs/connectors">connector</a>, if you've <a href="https://docs.cohere.com/docs/creating-and-deploying-a-connector">created</a> one.</p>
         * <p>When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage connectors(List<ChatConnector> connectors) {
            this.connectors = Optional.of(connectors);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "connectors", nulls = Nulls.SKIP)
        public _FinalStage connectors(Optional<List<ChatConnector>> connectors) {
            this.connectors = connectors;
            return this;
        }

        /**
         * <p>Defaults to <code>AUTO</code> when <code>connectors</code> are specified and <code>OFF</code> in all other cases.</p>
         * <p>Dictates how the prompt will be constructed.</p>
         * <p>With <code>prompt_truncation</code> set to &quot;AUTO&quot;, some elements from <code>chat_history</code> and <code>documents</code> will be dropped in an attempt to construct a prompt that fits within the model's context length limit.</p>
         * <p>With <code>prompt_truncation</code> set to &quot;OFF&quot;, no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a <code>TooManyTokens</code> error will be returned.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage promptTruncation(ChatRequestPromptTruncation promptTruncation) {
            this.promptTruncation = Optional.of(promptTruncation);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "prompt_truncation", nulls = Nulls.SKIP)
        public _FinalStage promptTruncation(Optional<ChatRequestPromptTruncation> promptTruncation) {
            this.promptTruncation = promptTruncation;
            return this;
        }

        /**
         * <p>An alternative to <code>chat_history</code>. Previous conversations can be resumed by providing the conversation's identifier. The contents of <code>message</code> and the model's response will be stored as part of this conversation.</p>
         * <p>If a conversation with this id does not already exist, a new conversation will be created.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage conversationId(String conversationId) {
            this.conversationId = Optional.of(conversationId);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "conversation_id", nulls = Nulls.SKIP)
        public _FinalStage conversationId(Optional<String> conversationId) {
            this.conversationId = conversationId;
            return this;
        }

        /**
         * <p>A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's <code>message</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage chatHistory(List<ChatMessage> chatHistory) {
            this.chatHistory = Optional.of(chatHistory);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "chat_history", nulls = Nulls.SKIP)
        public _FinalStage chatHistory(Optional<List<ChatMessage>> chatHistory) {
            this.chatHistory = chatHistory;
            return this;
        }

        /**
         * <p>When specified, the default Cohere preamble will be replaced with the provided one.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage preambleOverride(String preambleOverride) {
            this.preambleOverride = Optional.of(preambleOverride);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "preamble_override", nulls = Nulls.SKIP)
        public _FinalStage preambleOverride(Optional<String> preambleOverride) {
            this.preambleOverride = preambleOverride;
            return this;
        }

        /**
         * <p>Defaults to <code>command</code>.</p>
         * <p>The identifier of the model, which can be one of the existing Cohere models or the full ID for a <a href="https://docs.cohere.com/docs/chat-fine-tuning">fine-tuned custom model</a>.</p>
         * <p>Compatible Cohere models are <code>command</code> and <code>command-light</code> as well as the experimental <code>command-nightly</code> and <code>command-light-nightly</code> variants. Read more about <a href="https://docs.cohere.com/docs/models">Cohere models</a>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage model(String model) {
            this.model = Optional.of(model);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "model", nulls = Nulls.SKIP)
        public _FinalStage model(Optional<String> model) {
            this.model = model;
            return this;
        }

        @java.lang.Override
        public ChatRequest build() {
            return new ChatRequest(
                    message,
                    model,
                    preambleOverride,
                    chatHistory,
                    conversationId,
                    promptTruncation,
                    connectors,
                    searchQueriesOnly,
                    documents,
                    citationQuality,
                    temperature,
                    maxTokens,
                    k,
                    p,
                    frequencyPenalty,
                    presencePenalty,
                    additionalProperties);
        }
    }
}
